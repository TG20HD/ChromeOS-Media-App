// Copyright 2021 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
const impl={data_:{},set data(value){impl.data_=value},getValue:id=>impl.data_[id],getString:id=>impl.data_[id],getBoolean:id=>impl.data_[id],getInteger:id=>impl.data_[id],valueExists:id=>impl.data_[id]!==undefined};window["loadTimeData"]=impl;
// Copyright 2020 The Chromium Authors
function serializeError(error){return{message:error.message||"",name:error.name||"",stack:error.stack||""}}class NativeResolver{constructor(){this.resolve;this.reject;this.promise=new Promise(((resolve,reject)=>{this.resolve=resolve;this.reject=reject}))}}function assertCast(condition){if(!condition){throw new Error("Failed assertion")}return condition}const ReservedMessageTypes={RESPONSE_TYPE:"___response",ERROR_TYPE:"___error"};function isGeneratedMessage(messageType){return messageType.substr(0,3)==="___"}function throwIfReserved(messageType){if(isGeneratedMessage(messageType)){throw new Error(`Unexpected reserved message type: '${messageType}'`)}}class MessagePipe{constructor(targetOrigin,target,rethrowErrors=true){if(!target){const frame=document.querySelector(`iframe[src^='${targetOrigin}']`);if(!frame||!frame.contentWindow){throw new Error("Unable to locate target content window.")}target=assertCast(frame.contentWindow)}this.target_=target;this.targetOrigin_=targetOrigin;this.rethrowErrors=rethrowErrors;this.logClientError=object=>console.error(JSON.stringify(object));this.messageHandlers_=new Map;this.pendingMessages_=new Map;this.nextMessageId_=0;this.messageListener_=m=>this.receiveMessage_(m);console.assert(this.target_!==window,"target !== window");window.addEventListener("message",this.messageListener_)}registerHandler(messageType,handler){throwIfReserved(messageType);if(this.messageHandlers_.has(messageType)){throw new Error(`A handler already exists for ${messageType}`)}this.messageHandlers_.set(messageType,handler)}async sendMessage(messageType,message={}){try{return await this.sendMessageImpl(messageType,message)}catch(errorResponse){const error=new Error(`${messageType}: ${errorResponse.message}`);error.name=errorResponse.name||"Unknown Error";error.stack+=`\nError from ${this.targetOrigin_}\n${errorResponse.stack}`;throw error}}async sendMessageImpl(messageType,message={}){throwIfReserved(messageType);const messageId=this.nextMessageId_++;const resolver=new NativeResolver;this.pendingMessages_.set(messageId,resolver);this.postToTarget_(messageType,message,messageId);return resolver.promise}detach(){window.removeEventListener("message",this.messageListener_)}handleMessageResponse_(messageType,message,messageId){const{RESPONSE_TYPE:RESPONSE_TYPE,ERROR_TYPE:ERROR_TYPE}=ReservedMessageTypes;const resolver=this.pendingMessages_.get(messageId);if(messageType===RESPONSE_TYPE){resolver.resolve(message)}else if(messageType===ERROR_TYPE){this.logClientError(message);resolver.reject(message)}else{console.error(`Response for message ${messageId} received with invalid message type ${messageType}`)}this.pendingMessages_.delete(messageId)}async callHandlerForMessageType_(messageType,message,messageId){const{RESPONSE_TYPE:RESPONSE_TYPE,ERROR_TYPE:ERROR_TYPE}=ReservedMessageTypes;let response;let error=null;let sawError=false;try{response=await this.messageHandlers_.get(messageType)(message)}catch(err){sawError=true;error=err;response=serializeError(err)}this.postToTarget_(sawError?ERROR_TYPE:RESPONSE_TYPE,response,messageId);if(sawError&&this.rethrowErrors){this.logClientError(error);throw error}}receiveMessage_(event){const e=event;if(typeof e.data!=="object"||!e.data||typeof e.data.type!=="string"){return}const{messageId:messageId,type:type,message:message}=e.data;const{ERROR_TYPE:ERROR_TYPE}=ReservedMessageTypes;if(e.origin!==this.targetOrigin_&&this.targetOrigin_!=="*"){return}if(isGeneratedMessage(type)&&this.pendingMessages_.has(messageId)){this.handleMessageResponse_(type,message,messageId);return}if(isGeneratedMessage(type)){console.error(`Response with type ${type} for unknown message received.`);return}if(!this.messageHandlers_.has(type)){const error=new Error(`No handler registered for message type '${type}'`);const errorResponse=serializeError(error);this.postToTarget_(ERROR_TYPE,errorResponse,messageId);return}this.callHandlerForMessageType_(type,message,messageId)}postToTarget_(messageType,message,messageId){const messageWrapper={messageId:messageId,type:messageType,message:message||{}};this.target_.postMessage(messageWrapper,this.targetOrigin_)}}
// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
const Message={DELETE_FILE:"delete-file",EDIT_IN_PHOTOS:"edit-in-photos",IFRAME_READY:"iframe-ready",IS_FILE_ARC_WRITABLE:"is-file-arc-writable",IS_FILE_BROWSER_WRITABLE:"is-file-browser-writable",LOAD_EXTRA_FILES:"load-extra-files",LOAD_FILES:"load-files",MAYBE_TRIGGER_PDF_HATS:"maybe-trigger-pdf-hats",NAVIGATE:"navigate",NOTIFY_CURRENT_FILE:"notify-current-file",OPEN_ALLOWED_FILE:"open-allowed-file",OPEN_FEEDBACK_DIALOG:"open-feedback-dialog",OPEN_FILES_WITH_PICKER:"open-files-with-picker",OPEN_IN_SANDBOXED_VIEWER:"open-in-sandboxed-viewer",OVERWRITE_FILE:"overwrite-file",RELOAD_MAIN_FRAME:"reload-main-frame",RENAME_FILE:"rename-file",REQUEST_SAVE_FILE:"request-save-file",SAVE_AS:"save-as",TOGGLE_BROWSER_FULLSCREEN_MODE:"toggle-browser-fullscreen-mode"};const RenameResult={FILE_NO_LONGER_IN_LAST_OPENED_DIRECTORY:-1,SUCCESS:0,FILE_EXISTS:1};
// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
let _piexLoadPromise=null;function loadPiex(){async function startLoad(){function loadJs(path,module){return new Promise(((resolve,reject)=>{const script=document.createElement("script");script.onload=resolve;script.onerror=reject;if(module){script.type="module"}script.src=path;if(document.head){document.head.appendChild(script)}}))}await loadJs("piex/piex.js.wasm",false);await loadJs("piex_module.js",true);return window["extractFromRawImageBuffer"]}if(!_piexLoadPromise){_piexLoadPromise=startLoad()}return _piexLoadPromise}
// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
window.addEventListener("simulate-type-error-for-test",(event=>{event.notAFunction()}));window.addEventListener("simulate-unhandled-rejection-for-test",(event=>{new Promise((resolve=>{const error=new Error("fake_throw");error.name="FakeErrorName";throw error}))}));window.addEventListener("simulate-unhandled-rejection-with-dom-exception-for-test",(event=>{new Promise((resolve=>{throw new DOMException("Not a file.","NotAFile")}))}));
// Copyright 2019 The Chromium Authors
const parentMessagePipe=new MessagePipe("chrome://media-app",window.parent);const PLACEHOLDER_BLOB=new Blob([]);class ReceivedFile{constructor(file){this.blob=file.file||PLACEHOLDER_BLOB;this.name=file.name;this.size=this.blob.size;this.mimeType=this.blob.type;this.token=file.token;this.error=file.error;this.fromClipboard=false;if(file.canDelete){this.deleteOriginalFile=()=>this.deleteOriginalFileImpl()}if(file.canRename){this.renameOriginalFile=newName=>this.renameOriginalFileImpl(newName)}}async isArcWritable(){const message={token:this.token};const{writable:writable}=await parentMessagePipe.sendMessage(Message.IS_FILE_ARC_WRITABLE,message);return writable}async isBrowserWritable(){const message={token:this.token};const{writable:writable}=await parentMessagePipe.sendMessage(Message.IS_FILE_BROWSER_WRITABLE,message);return writable}async editInPhotos(){const message={token:this.token,mimeType:this.mimeType};await parentMessagePipe.sendMessage(Message.EDIT_IN_PHOTOS,message)}async overwriteOriginal(blob){const message={token:this.token,blob:blob};const result=await parentMessagePipe.sendMessage(Message.OVERWRITE_FILE,message);if(result.renamedTo){this.name=result.renamedTo;delete this.deleteOriginalFile;delete this.renameOriginalFile}this.error=result.errorName||"";this.updateFile(blob,this.name)}async deleteOriginalFileImpl(){await parentMessagePipe.sendMessage(Message.DELETE_FILE,{token:this.token});return 0}async renameOriginalFileImpl(newName){const renameResponse=await parentMessagePipe.sendMessage(Message.RENAME_FILE,{token:this.token,newFilename:newName});if(renameResponse.renameResult===RenameResult.SUCCESS){this.name=newName}return renameResponse.renameResult}async saveAs(blob,pickedFileToken){const message={blob:blob,oldFileToken:this.token,pickedFileToken:pickedFileToken};const result=await parentMessagePipe.sendMessage(Message.SAVE_AS,message);this.updateFile(blob,result.newFilename);delete this.deleteOriginalFile;delete this.renameOriginalFile}async getExportFile(accept){const msg={suggestedName:this.name,mimeType:this.mimeType,startInToken:this.token,accept:accept};const response=await parentMessagePipe.sendMessage(Message.REQUEST_SAVE_FILE,msg);return new ReceivedFile(response.pickedFileContext)}async openFile(){const msg={fileToken:this.token};const response=await parentMessagePipe.sendMessage(Message.OPEN_ALLOWED_FILE,msg);return response.file}updateFile(blob,name){this.blob=new File([blob],name,{type:blob.type});this.size=blob.size;this.mimeType=blob.type;this.name=name}}let lastLoadedReceivedFileList=null;class ReceivedFileList{constructor(filesMessage){const{files:files,currentFileIndex:currentFileIndex}=filesMessage;if(files.length){this.currentFileIndex=currentFileIndex>=0?currentFileIndex:0}else{this.currentFileIndex=-1}this.length=files.length;this.files=files.map((f=>new ReceivedFile(f)));this.observers=[]}item(index){return this.files[index]||null}async loadNext(currentFileToken){await parentMessagePipe.sendMessage(Message.NAVIGATE,{currentFileToken:currentFileToken,direction:1})}async loadPrev(currentFileToken){await parentMessagePipe.sendMessage(Message.NAVIGATE,{currentFileToken:currentFileToken,direction:-1})}addObserver(observer){this.observers.push(observer)}async openFilesWithFilePicker(acceptTypeKeys,startInFolder,isSingleFile){const fileRep=startInFolder;const startInToken=startInFolder?fileRep.token||0:0;const msg={startInToken:startInToken>0?startInToken:0,accept:acceptTypeKeys,isSingleFile:isSingleFile};await parentMessagePipe.sendMessage(Message.OPEN_FILES_WITH_PICKER,msg)}filterInPlace(filter){this.files=this.files.filter(filter);this.length=this.files.length;this.currentFileIndex=this.length>0?0:-1}addFiles(files){if(files.length===0){return}this.files=[...this.files,...files];this.length=this.files.length;this.observers.map((o=>o(this)))}}parentMessagePipe.registerHandler(Message.LOAD_FILES,(async message=>{const filesMessage=message;lastLoadedReceivedFileList=new ReceivedFileList(filesMessage);await loadFiles(lastLoadedReceivedFileList)}));parentMessagePipe.registerHandler(Message.LOAD_EXTRA_FILES,(async message=>{if(!lastLoadedReceivedFileList){return}const extraFilesMessage=message;const newFiles=extraFilesMessage.files.map((f=>new ReceivedFile(f)));lastLoadedReceivedFileList.addFiles(newFiles)}));parentMessagePipe.sendMessage(Message.IFRAME_READY);const DELEGATE={async openFeedbackDialog(){const response=await parentMessagePipe.sendMessage(Message.OPEN_FEEDBACK_DIALOG);return response["errorMessage"]},async toggleBrowserFullscreenMode(){await parentMessagePipe.sendMessage(Message.TOGGLE_BROWSER_FULLSCREEN_MODE)},async requestSaveFile(suggestedName,mimeType,accept){const msg={suggestedName:suggestedName,mimeType:mimeType,startInToken:0,accept:accept};const response=await parentMessagePipe.sendMessage(Message.REQUEST_SAVE_FILE,msg);return new ReceivedFile(response.pickedFileContext)},notifyCurrentFile(name,type){parentMessagePipe.sendMessage(Message.NOTIFY_CURRENT_FILE,{name:name,type:type})},async extractPreview(file){try{const bufferPromise=file.arrayBuffer();const extractFromRawImageBuffer=await loadPiex();return await extractFromRawImageBuffer(await bufferPromise)}catch(e){console.warn(e);if(e.name==="Error"){e.name="JpegNotFound"}throw e}},openInSandboxedViewer(title,blobUuid){parentMessagePipe.sendMessage(Message.OPEN_IN_SANDBOXED_VIEWER,{title:title,blobUuid:blobUuid})},reloadMainFrame(){parentMessagePipe.sendMessage(Message.RELOAD_MAIN_FRAME)},maybeTriggerPdfHats(){parentMessagePipe.sendMessage(Message.MAYBE_TRIGGER_PDF_HATS)}};function getApp(){return document.querySelector("backlight-app")}async function loadFiles(fileList){const app=getApp();if(app){await app.loadFiles(fileList)}else{window.customLaunchData.files=fileList}}function initializeApp(app){app.setDelegate(DELEGATE)}function mutationCallback(mutationsList,observer){const app=getApp();if(!app){return}initializeApp(app);observer.disconnect()}window.addEventListener("DOMContentLoaded",(()=>{const app=getApp();if(app){initializeApp(app);return}const observer=new MutationObserver(mutationCallback);observer.observe(document.body,{childList:true})}));window.customLaunchData={delegate:DELEGATE,files:new ReceivedFileList({files:[],currentFileIndex:-1})};
// Attempting to show file pickers in the sandboxed <iframe> is guaranteed to
window["chooseFileSystemEntries"]=null;window["showOpenFilePicker"]=null;window["showSaveFilePicker"]=null;window["showDirectoryPicker"]=null;const TEST_ONLY={RenameResult:RenameResult,DELEGATE:DELEGATE,assertCast:assertCast,parentMessagePipe:parentMessagePipe,loadFiles:loadFiles,setLoadFiles:spy=>{loadFiles=spy}};window["lastLoadedReceivedFileList"]=()=>lastLoadedReceivedFileList;export{ReceivedFileList,TEST_ONLY};